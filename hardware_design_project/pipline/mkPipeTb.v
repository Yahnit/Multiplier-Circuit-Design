//
// Generated by Bluespec Compiler, version 2016.07.beta1 (build 34806, 2016-07-05)
//
// On Wed Mar  8 19:30:43 IST 2017
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkPipeTb(CLK,
		RST_N);
  input  CLK;
  input  RST_N;

  // register count
  reg [31 : 0] count;
  wire [31 : 0] count$D_IN;
  wire count$EN;

  // register cycle
  reg [31 : 0] cycle;
  wire [31 : 0] cycle$D_IN;
  wire cycle$EN;

  // register flag
  reg flag;
  wire flag$D_IN, flag$EN;

  // register x
  reg [31 : 0] x;
  wire [31 : 0] x$D_IN;
  wire x$EN;

  // register y
  reg [15 : 0] y;
  wire [15 : 0] y$D_IN;
  wire y$EN;

  // ports of submodule dut
  wire [31 : 0] dut$result, dut$start_m1;
  wire [15 : 0] dut$start_m2;
  wire dut$EN_reset, dut$EN_start, dut$RDY_result, dut$RDY_start;

  // ports of submodule queue1
  wire [31 : 0] queue1$D_IN, queue1$D_OUT;
  wire queue1$CLR, queue1$DEQ, queue1$EMPTY_N, queue1$ENQ, queue1$FULL_N;

  // ports of submodule queue2
  wire [15 : 0] queue2$D_IN, queue2$D_OUT;
  wire queue2$CLR, queue2$DEQ, queue2$EMPTY_N, queue2$ENQ, queue2$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_rule_tb_1, WILL_FIRE_RL_rule_tb_2, WILL_FIRE_RL_stop;

  // remaining internal signals
  wire [63 : 0] queue1_first__3_MUL_0_CONCAT_queue2_first__4_5___d26;
  wire NOT_dut_result__2_EQ_queue1_first__3_MUL_0_CON_ETC___d29,
       count_ULT_100___d10;

  // submodule dut
  mkPipeline dut(.CLK(CLK),
		 .RST_N(RST_N),
		 .start_m1(dut$start_m1),
		 .start_m2(dut$start_m2),
		 .EN_start(dut$EN_start),
		 .EN_reset(dut$EN_reset),
		 .RDY_start(dut$RDY_start),
		 .result(dut$result),
		 .RDY_result(dut$RDY_result),
		 .RDY_reset());

  // submodule queue1
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd20),
	      .p3cntr_width(32'd5),
	      .guarded(32'd1)) queue1(.RST(RST_N),
				      .CLK(CLK),
				      .D_IN(queue1$D_IN),
				      .ENQ(queue1$ENQ),
				      .DEQ(queue1$DEQ),
				      .CLR(queue1$CLR),
				      .D_OUT(queue1$D_OUT),
				      .FULL_N(queue1$FULL_N),
				      .EMPTY_N(queue1$EMPTY_N));

  // submodule queue2
  SizedFIFO #(.p1width(32'd16),
	      .p2depth(32'd20),
	      .p3cntr_width(32'd5),
	      .guarded(32'd1)) queue2(.RST(RST_N),
				      .CLK(CLK),
				      .D_IN(queue2$D_IN),
				      .ENQ(queue2$ENQ),
				      .DEQ(queue2$DEQ),
				      .CLR(queue2$CLR),
				      .D_OUT(queue2$D_OUT),
				      .FULL_N(queue2$FULL_N),
				      .EMPTY_N(queue2$EMPTY_N));

  // rule RL_rule_tb_2
  assign WILL_FIRE_RL_rule_tb_2 =
	     dut$RDY_result && queue1$EMPTY_N && queue2$EMPTY_N ;

  // rule RL_rule_tb_1
  assign WILL_FIRE_RL_rule_tb_1 =
	     dut$RDY_start && queue1$FULL_N && queue2$FULL_N &&
	     count_ULT_100___d10 ;

  // rule RL_stop
  assign WILL_FIRE_RL_stop = !count_ULT_100___d10 && !queue1$EMPTY_N ;

  // register count
  assign count$D_IN = count + 32'd1 ;
  assign count$EN = WILL_FIRE_RL_rule_tb_1 ;

  // register cycle
  assign cycle$D_IN = cycle + 32'd1 ;
  assign cycle$EN = 1'd1 ;

  // register flag
  assign flag$D_IN = 1'd1 ;
  assign flag$EN = !count_ULT_100___d10 && !flag ;

  // register x
  assign x$D_IN = x + 32'd11 ;
  assign x$EN = WILL_FIRE_RL_rule_tb_1 ;

  // register y
  assign y$D_IN = y + 16'd48 ;
  assign y$EN = WILL_FIRE_RL_rule_tb_1 ;

  // submodule dut
  assign dut$start_m1 = x ;
  assign dut$start_m2 = y ;
  assign dut$EN_start = WILL_FIRE_RL_rule_tb_1 ;
  assign dut$EN_reset = !count_ULT_100___d10 && !flag ;

  // submodule queue1
  assign queue1$D_IN = x ;
  assign queue1$ENQ = WILL_FIRE_RL_rule_tb_1 ;
  assign queue1$DEQ = WILL_FIRE_RL_rule_tb_2 ;
  assign queue1$CLR = 1'b0 ;

  // submodule queue2
  assign queue2$D_IN = y ;
  assign queue2$ENQ = WILL_FIRE_RL_rule_tb_1 ;
  assign queue2$DEQ = WILL_FIRE_RL_rule_tb_2 ;
  assign queue2$CLR = 1'b0 ;

  // remaining internal signals
  assign NOT_dut_result__2_EQ_queue1_first__3_MUL_0_CON_ETC___d29 =
	     dut$result !=
	     queue1_first__3_MUL_0_CONCAT_queue2_first__4_5___d26[31:0] ;
  assign count_ULT_100___d10 = count < 32'd100 ;
  assign queue1_first__3_MUL_0_CONCAT_queue2_first__4_5___d26 =
	     queue1$D_OUT * { 16'd0, queue2$D_OUT } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        count <= `BSV_ASSIGNMENT_DELAY 32'd1;
	cycle <= `BSV_ASSIGNMENT_DELAY 32'd0;
	flag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	x <= `BSV_ASSIGNMENT_DELAY 32'd1;
	y <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (count$EN) count <= `BSV_ASSIGNMENT_DELAY count$D_IN;
	if (cycle$EN) cycle <= `BSV_ASSIGNMENT_DELAY cycle$D_IN;
	if (flag$EN) flag <= `BSV_ASSIGNMENT_DELAY flag$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    count = 32'hAAAAAAAA;
    cycle = 32'hAAAAAAAA;
    flag = 1'h0;
    x = 32'hAAAAAAAA;
    y = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      $display("------Cycle %0d------", $signed(cycle));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2) $display("Rule TAKE OUTPUT fired");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2)
	$display("    Result = %0d Expected = %0d",
		 dut$result,
		 queue1_first__3_MUL_0_CONCAT_queue2_first__4_5___d26[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2 &&
	  NOT_dut_result__2_EQ_queue1_first__3_MUL_0_CON_ETC___d29)
	$display("Error");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2 &&
	  NOT_dut_result__2_EQ_queue1_first__3_MUL_0_CON_ETC___d29)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_2)
	$display("*************************************************");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_1) $display("Rule GIVE INPUT fired");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rule_tb_1)
	$display("Test Input: x = %0d, y = %0d", x, y);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_stop) $display("\t finish");
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_stop) $finish(32'd0);
  end
  // synopsys translate_on
endmodule  // mkPipeTb

